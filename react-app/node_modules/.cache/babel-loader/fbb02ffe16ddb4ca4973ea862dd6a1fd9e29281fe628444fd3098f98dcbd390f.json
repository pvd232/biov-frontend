{"ast":null,"code":"var _jsxFileName = \"/Users/machina/Developer/biov-front/src/components/pages/splash/landing_page/Orb.tsx\",\n  _s = $RefreshSig$();\nimport { useCallback, useRef } from \"react\";\nimport { useTick } from \"@pixi/react\";\nimport { Graphics } from \"@pixi/react\";\nimport ScreenSize from \"../../../../types/enums/ScreenSize\";\nimport { useWindowWidth } from \"../../../../hooks/useWindowWidth\";\nimport { getOrbBounds } from \"./helpers/getOrbBounds\";\nimport { incrementOrbPosition } from \"./helpers/incrementOrbPosition\";\nimport { updateOrb } from \"./helpers/updateOrb\";\nimport { getOrbRadius } from \"./helpers/getOrbRadius\";\nimport { getOrbInitialPosition } from \"./helpers/getOrbInitialPosition\";\nimport { orbPositionRequiresUpdate } from \"./helpers/orbPositionRequiresUpdate\";\nimport useOrbData from \"./hooks/useOrbData\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Orb = props => {\n  _s();\n  const inc = 0.08;\n  const defaultPosition = {\n    position: {\n      x: 0,\n      y: 0\n    },\n    scale: {\n      x: 1,\n      y: 1\n    }\n  };\n  const orbRef = useRef(defaultPosition);\n  const windowWidth = useWindowWidth();\n  const xsScreen = windowWidth < ScreenSize.xs;\n  const bounds = (() => getOrbBounds(xsScreen, windowWidth, window.innerHeight))();\n  const [orbData, setOrbData] = useOrbData(bounds);\n  const draw = useCallback(g => {\n    const radius = (() => {\n      return getOrbRadius(xsScreen, windowWidth);\n    })();\n    const initialOrbPosition = getOrbInitialPosition(xsScreen, windowWidth, window.innerHeight, radius);\n    // Set relative position of Orb's bounding box to the initial position\n    g.x = initialOrbPosition.xPosition;\n    g.y = initialOrbPosition.yPosition;\n    g.scale.set(1);\n\n    // Clear anything currently drawn to graphics\n    g.clear();\n\n    // Tell graphics to fill any shapes drawn after this with the orb's fill color\n    g.beginFill(props.fill);\n    // Draw a circle with the given radius at the origin relative to the orb's bounding box\n    g.drawCircle(0, 0, radius);\n    // Let graphics know we won't be filling in any more shapes\n    g.endFill();\n  }, [xsScreen, props.fill, windowWidth]);\n  useTick(_delta => {\n    const yDelta = 0.25;\n    const xDelta = 0.25;\n    const scaleDelta = 0.001;\n    const updatedValues = (() => {\n      // If the orb has moved to it's destination, update the destination\n      if (orbPositionRequiresUpdate(orbRef.current.position.x, orbRef.current.position.y, orbRef.current.scale.x, orbData.xPosition, orbData.yPosition, orbData.scale, xDelta, yDelta, scaleDelta)) {\n        const updatedValues = updateOrb(orbData.xOffSet, orbData.yOffSet, bounds, inc);\n        setOrbData(updatedValues);\n        return updatedValues;\n      } else {\n        return orbData;\n      }\n    })();\n    const newCoordinates = incrementOrbPosition(updatedValues.xPosition, orbRef.current.position.x, updatedValues.yPosition, orbRef.current.position.y, updatedValues.scale, orbRef.current.scale.x, xDelta, yDelta, scaleDelta);\n    orbRef.current.position.x = newCoordinates.xPosition;\n    orbRef.current.position.y = newCoordinates.yPosition;\n    orbRef.current.scale.x = newCoordinates.scale;\n    orbRef.current.scale.y = newCoordinates.scale;\n  });\n  return /*#__PURE__*/_jsxDEV(Graphics, {\n    draw: draw,\n    ref: orbRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 114,\n    columnNumber: 10\n  }, this);\n};\n_s(Orb, \"2P1r8Q7Ud+v+6to94Us8nSxL2SE=\", false, function () {\n  return [useWindowWidth, useOrbData, useTick];\n});\n_c = Orb;\nexport default Orb;\nvar _c;\n$RefreshReg$(_c, \"Orb\");","map":{"version":3,"names":["useCallback","useRef","useTick","Graphics","ScreenSize","useWindowWidth","getOrbBounds","incrementOrbPosition","updateOrb","getOrbRadius","getOrbInitialPosition","orbPositionRequiresUpdate","useOrbData","jsxDEV","_jsxDEV","Orb","props","_s","inc","defaultPosition","position","x","y","scale","orbRef","windowWidth","xsScreen","xs","bounds","window","innerHeight","orbData","setOrbData","draw","g","radius","initialOrbPosition","xPosition","yPosition","set","clear","beginFill","fill","drawCircle","endFill","_delta","yDelta","xDelta","scaleDelta","updatedValues","current","xOffSet","yOffSet","newCoordinates","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/machina/Developer/biov-front/src/components/pages/splash/landing_page/Orb.tsx"],"sourcesContent":["import { useCallback, useRef, ComponentProps } from \"react\";\nimport { useTick } from \"@pixi/react\";\nimport { Graphics, PixiRef } from \"@pixi/react\";\nimport ScreenSize from \"../../../../types/enums/ScreenSize\";\nimport { useWindowWidth } from \"../../../../hooks/useWindowWidth\";\nimport PixiPosition from \"./types/PixiPosition\";\nimport OrbProps from \"./types/OrbProps\";\nimport { getOrbBounds } from \"./helpers/getOrbBounds\";\nimport { incrementOrbPosition } from \"./helpers/incrementOrbPosition\";\nimport { updateOrb } from \"./helpers/updateOrb\";\nimport { getOrbRadius } from \"./helpers/getOrbRadius\";\nimport { getOrbInitialPosition } from \"./helpers/getOrbInitialPosition\";\nimport { orbPositionRequiresUpdate } from \"./helpers/orbPositionRequiresUpdate\";\nimport useOrbData from \"./hooks/useOrbData\";\nconst Orb = (props: OrbProps) => {\n  const inc = 0.08;\n  const defaultPosition = {\n    position: {\n      x: 0,\n      y: 0,\n    },\n    scale: {\n      x: 1,\n      y: 1,\n    },\n  };\n  const orbRef = useRef<PixiRef<PixiPosition>>(\n    defaultPosition as PixiRef<PixiPosition>\n  );\n  const windowWidth = useWindowWidth();\n\n  const xsScreen = windowWidth < ScreenSize.xs;\n  const bounds = (() =>\n    getOrbBounds(xsScreen, windowWidth, window.innerHeight))();\n\n  const [orbData, setOrbData] = useOrbData(bounds);\n  type Draw = NonNullable<ComponentProps<typeof Graphics>[\"draw\"]>;\n  const draw = useCallback<Draw>(\n    (g) => {\n      const radius = (() => {\n        return getOrbRadius(xsScreen, windowWidth);\n      })();\n      const initialOrbPosition = getOrbInitialPosition(\n        xsScreen,\n        windowWidth,\n        window.innerHeight,\n        radius\n      );\n      // Set relative position of Orb's bounding box to the initial position\n      g.x = initialOrbPosition.xPosition;\n      g.y = initialOrbPosition.yPosition;\n      g.scale.set(1);\n\n      // Clear anything currently drawn to graphics\n      g.clear();\n\n      // Tell graphics to fill any shapes drawn after this with the orb's fill color\n      g.beginFill(props.fill);\n      // Draw a circle with the given radius at the origin relative to the orb's bounding box\n      g.drawCircle(0, 0, radius);\n      // Let graphics know we won't be filling in any more shapes\n      g.endFill();\n    },\n    [xsScreen, props.fill, windowWidth]\n  );\n  useTick((_delta) => {\n    const yDelta = 0.25;\n    const xDelta = 0.25;\n    const scaleDelta = 0.001;\n    const updatedValues = (() => {\n      // If the orb has moved to it's destination, update the destination\n      if (\n        orbPositionRequiresUpdate(\n          orbRef.current.position.x,\n          orbRef.current.position.y,\n          orbRef.current.scale.x,\n          orbData.xPosition,\n          orbData.yPosition,\n          orbData.scale,\n          xDelta,\n          yDelta,\n          scaleDelta\n        )\n      ) {\n        const updatedValues = updateOrb(\n          orbData.xOffSet,\n          orbData.yOffSet,\n          bounds,\n          inc\n        );\n        setOrbData(updatedValues);\n        return updatedValues;\n      } else {\n        return orbData;\n      }\n    })();\n    const newCoordinates = incrementOrbPosition(\n      updatedValues.xPosition,\n      orbRef.current.position.x,\n      updatedValues.yPosition,\n      orbRef.current.position.y,\n      updatedValues.scale,\n      orbRef.current.scale.x,\n      xDelta,\n      yDelta,\n      scaleDelta\n    );\n\n    orbRef.current.position.x = newCoordinates.xPosition;\n    orbRef.current.position.y = newCoordinates.yPosition;\n    orbRef.current.scale.x = newCoordinates.scale;\n    orbRef.current.scale.y = newCoordinates.scale;\n  });\n  return <Graphics draw={draw} ref={orbRef} />;\n};\nexport default Orb;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}